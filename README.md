OSINT  PHASE 1
https://osintframework.com/ 
https://smart.myosint.training/
spiderfoot -l 127.0.0.1:5001   |   spiderfoot -M | grep [search term]
Step 3: Run a SpiderFoot Scan for a Domain.
Click the New Scan tab in the GUI.
Enter a name for the scan and select a target. In this case, we will use h4cker.org.
You will scan by use case. Note that you can also scan by the type of information required or by selecting the individual scanner modules that you would like to use. By executing narrower scans, you can learn more about the modules and information that can be gathered.
Select the scan use case as Footprint.
Note: The All use case scan may use active scanning. Unless you have permission to scan the target, you should avoid this setting. To be completely safe, the Passive use case should avoid any problems with unauthorized scanning.

Click the Run Scan Now button.
You should see a bar graph appear. The scan statistics will start to increment, and new bars will appear in the graph as new results are obtained. Mouse over the bars for a summary of the findings for that data type.
SpiderFoot scans are very detailed and can take a very long time. Give this scan at least 30 minutes so that there is a nice collection of information. To get the most details, a scan could take hours. While the scan is running, you can browse the results.
Step 4: Investigate Scan Results.
Go back to the scan results, by clicking the Scans tab. You will see a table with the currently running scan and any previous scans displayed.
Click the black square in the right-most column of the scans table to stop the scan. Some information is not available until the scan is aborted or completed.
Click the name of the scan in the table to return to the scan view. You will be taken to the Browse tab. Each row in the table represents data found by the various modules. Some modules contribute to multiple types of data.
Investigate the results.
Step 5: Register API Keys (optional).
API keys will enhance the functionality of SpiderFoot. Some of these API keys require free registration. The pentesting tools that are available are constantly evolving. Some tools or services that were once free and open can become fee-based over time.

Note: Some APIs may limit your results after you have reached a prescribed number of uses.

Enter the API keys in the settings for each module. Be sure to save your changes.
Click New Scan. Go to the By Module tab. Select only the modules for which you have added API keys. All other modules should be unchecked.
Enter the target as h4cker.org and click Start Scan. Feel free to scan other domains but be sure to observe the terms and conditions of this course.
Step 6: Analyze Results of API Modules Scans.
This scan should not take very long.
Browse the scan to look at the results. Pay attention to the Source Module column. You should see some of the scanners that you configured with API keys.
Go to the Leak Site URL type in the table of results.

 Recon-ng

----------------------
PHASE 2


DNSRecon
nslookup, host, and dig Linux commands, to perform name resolution and obtain additional information about a domain.
whois commaand
nsloopup
host command
sslscan 
inspect domain ssl cert

CHECK FOR LEAKS ????: tool that allows you to find email addresses and passwords exposed in previous breaches is h8mail. You can install h8mail by using the pip3 install h8mail command
The following are additional tools that allow you to search for breach data dumps:

WhatBreach: https://github.com/Ekultek/WhatBreach
LeakLooker: https://github.com/woj-ciech/LeakLooker
Buster: https://github.com/sham00n/buster
Scavenger: https://github.com/rndinfosecguy/Scavenger
PwnDB: https://github.com/davidtavarez/pwndb

metadata recon: exiftool IMG_4730.jpg

DORKING : https://www.exploit-db.com/google-hacking-database/
Filetype: Directs Google to search only within the text of a particular type of file (for example, filetype:xls)
Inurl: Directs Google to search only within the specified URL of a document (for example, inurl:search-text)
Link: Directs Google to search within hyperlinks for a specific term (for example, link:www.domain.com)
Intitle: Directs Google to search for a term within the title of a document (for example, intitle: “Index of /etc”)
Search the target company site using the inurl: operator.
In the search window type the command site:examplecompany.com inurl:admin replacing examplecompany.com with a company of your choice.

This will return pages that have the keyword admin somewhere inside the URL.

Review the returned pages and click a few to see if there is any interesting information.

Do another search, this time using the intitle: operator.
In the search window type the command site:examplecompany.com intitle:login.

This will return pages that have the keyword login in the title. Again, review the results and click a few to see if there is any interesting information.

Next, try using the filetype: operator.
In the search window, type the command site:examplecompany.com filetype:pdf.

This will return PDF files. Review some of the files to see if there is any interesting information that is not intended for public access or is useful for social engineering attacks.

Try a search with multiple operators. Use the intext: and filetype: operators. In the search window, type the command site:examplecompany.com intext:employee filetype:pdf
This will return PDF pages containing the text employee.

Experiment with site:examplecompany.com intext:<keyword> filetype:<file type> using different key words and different filetypes.
LinkedIn can offer valuable information about a company and employees. In the search window, type the command site:linkedin.com intitle:example company. Experiment by searching for the company name with and without the .com at the end.
What type of information could a hacker gain from this type of dork?
periment with site:<social media site> intitle:example company and search other social media sites.

WAY BACK MACHINE : 
https://archive.org/web

OLD GITHUB REPOS

Step 1: Start Recon-ng

To start using Recon-ng, you simply run recon-ng from a new terminal window. Example 3-11 shows the command and the initial menu that Recon-ng starts with.
Step 2. View available commands

To get an idea of what commands are available in the Recon-ng command-line tool, you can simply type help and press Enter. Example 3-12 shows the output of the help command.

Example 3-12 - Recon-ng help Command

Step 3. Search for available modules.

Before you can start gathering information using the Recon-ng tool, you need to understand what modules are available. (You can see from the initial screen in Example 3-11 the current number of modules that are installed in Recon-ng.) Recon-ng comes with a “marketplace,” where you can search for available modules to be installed. You can use the marketplace search command to search for all the available modules in Recon-ng, as demonstrated in Example 3-13.

Scroll the output in Example 3-13 to the right to see the D and K columns The letter D indicates that the module has dependencies. The letter K indicates that an API key is needed in order to use the resources used in a particular module. For example, the module with the path recon/companies-contacts/censys_email_address has dependencies and needs an API key in order to query the Censys database. (Censys is a very popular resource for querying OSINT data.)

Example 3-13 - The Recon-ng Marketplace Search

Step 4. Refresh the marketplace.

You can refresh the data about the available modules by using the marketplace refresh command, as shown in Example 3-14.

Example 3-14 - Refreshing the Recon-ng Marketplace Data

Step 5. Search the marketplace.

Let’s perform a quick search to find different subdomains of one of my domains (h4cker.org). We can use the module bing_domain_web to try to find any subdomains leveraging the Bing search engine. You can perform a keyword search for any modules by using the command marketplace search < keyword >, as demonstrated in Example 3-15.

Example 3-15 - Marketplace Keyword Search

Step 6. Install a module.

Several results matched the bing keyword. However, the one that we are interested in is recon/domains-hosts/bing_domain_web. You can install the module by using the marketplace install command, as shown in Example 3-16.

Example 3-16 - Installing a Recon-ng Module

Step 7. Show installed modules.

You can use the modules search command (as shown in Example 3-17) to show all the modules that have been installed in Recon-ng.

Example 3-17 - Recon-ng Installed Modules

Step 8. Load a module.

To load the module that you would like to use, use the modules load command. In Example 3-18, the bing_domain_web module is loaded. Notice that the prompt changed to include the name of the loaded module. After the module is loaded, you can display the module options by using the info command.

Example 3-18 - Loading an Installed Module in Recon-ng

Step 9. Change the source.

You can change the source (the domain to be used to find its subdomains) by using the command options set SOURCE, as demonstrated in Example 3-19. After the source domain is set, you can type run to run the query. The highlighted lines show that four subdomains were found using the bing_domain_web module.

Example 3-19 - Setting the Source Domain and Running the Query


Shodan

Part 3: Use Shodan from the CLI to Perform a Search
Step 1: Initialize Shodan and perform a search.
Find and copy your API key by selecting Account > Overview from the top right of the Shodan web site screen. Highlight the API key shown above the QR code, right-click the selection and select Copy. Make note of your key for future use.
Shodan is a Python library that is installed in Kali by default. Open a Kali terminal window.
At the prompt, enter the command shodan init and right click and select Paste Selection to paste the API key into the terminal. Your API key should appear at the end of the command.
┌──(root㉿kali)-[/home/kali]
└─$ shodan init <paste your API key here>
This command should return the string “Successfully initialized".

Enter the shodan -h command to display the list of Shodan commands available from the command line.
Execute the same search at the CLI that you did in the web search bar to view webcams that Shodan finds. At the CLI, you must enter the shodan search command before specifying the search criteria.
┌──(kali㉿kali)-[~]
└─$ shodan search webcam
The output of the command is unformatted text. The IP addresses of the devices that Shodan finds are highlighted along with the port and the device name. Press q to quit and return to the CLI prompt. Shodan CLI commands can be written into Python scripts to automate search and scanning functions.

Note: Searching with filters is not available with a free API key.

Step 2: Execute other Shodan CLI commands.
Not all commands listed are available in the free version of Shodan. The shodan info command will show how many credits that you currently have to perform searches or scans.
┌──(kali㉿kali)-[~]
└─$ shodan info
Query credits available: 0
Scan credits available: 0
For paid subscriptions, the available credits will reset each month. There are subscriptions available for a cost that permit unlimited queries and scans.

Use the shodan myip command to find the registered IP address that corresponds to your device.
The IP address returned is the source IP address that will be added to any packets sent from your device to a destination on the internet.

Another useful command is the stats command. It will return the summary information about a query, similar to what is displayed on the results page in the web version. To get the summary information, enter the stats command and the search query that you want to view the results.
┌──(kali㉿kali)-[~]
└─$ shodan stats webcam
This query returns the summary statistics for the webcam search.


END PASSIVE RECON
-----------------------------------------------
ACTIVE RECON

User endpoints: Desktops, laptops, mobile devices, and gaming consoles used by employees.
Facilities-related endpoints: Surveillance cameras, an alarm system, climate control sensors and actuators, lighting control systems, and VoIP systems.
Intermediary devices: Routers and switches that connect endpoints and other networks.
Wireless Access Points: Devices that provide Wi-Fi access to employees.
Firewalls: Devices that protect the network from external threats and unauthorized access.
Servers: On-premises servers that provide file storage, database access, and other services such as email.
Cloud Infrastructure: Amazon Web Services


NMAP - 
TCP Connect Scan (-sT)
UDP Scan (-sU)
TCP FIN Scan (-sF)
Host Discovery Scan (-sn)
Timing Options (-T 0-5)

TCP Connect Scan ( -sT )

A TCP connect scan actually makes use of the underlying operating system’s networking mechanism to establish a full TCP connection with the target device being scanned. Because it creates a full connection, it creates more traffic (and thus takes more time to run). This is the default scan type that is used if no scan type is specified with the nmap command. However, it should typically be used only when a SYN scan is not an option, such as when a user who is running the nmap command does not have raw packet privileges on the operating system because many of the Nmap scan types rely on writing raw packets. This section illustrates how a TCP connect scan works and provides an example of a scan from a Kali Linux system. Table 3-3 defines the TCP connect scan responses.

Table 3-3 - TCP Connect Scan Responses

UDP Scan ( -sU )

The majority of the time, you will be scanning for TCP ports, as this is how you connect to most services running on target systems. However, you might encounter some instances in which you need to scan for UDP ports – for example, if you are trying to enumerate a DNS, SNMP, or DHCP server. These services all use UDP for communication between client and server. To scan UDP ports, Nmap sends a UDP packet to all ports specified in the command-line configuration. It waits to hear back from the target. If it receives an ICMP port unreachable message back from a target, that port is marked as closed. If it receives no response from the target UDP port, Nmap marks the port as open/filtered. Table 3-4 shows the UDP scan responses.

Host Discovery Scan ( -sn )

A host discovery scan is one of the most common types of scans used to enumerate hosts on a network because it can use different types of ICMP messages to determine whether a host is online and responding on a network.

Timing Options ( -T 0-5 )

The Nmap scanner provides six timing templates that can be specified with the -T option and the template number (0 through 5) or name. Nmap timing templates enable you to dictate how aggressive a scan will be, while leaving Nmap to pick the exact timing values. These are the timing options:

-T0 (Paranoid) : Very slow, used for IDS evasion
-T1 (Sneaky) : Quite slow, used for IDS evasion
-T2 (Polite) : Slows down to consume less bandwidth, runs about 10 times slower than the default
-T3 (Normal) : Default, a dynamic timing model based on target responsiveness
-T4 (Aggressive) : Assumes a fast and reliable network and may overwhelm targets
-T5 (Insane) : Very aggressive; will likely overwhelm targets or miss open ports


Host Enumeration

The enumeration of hosts is one of the first tasks you need to perform in the information-gathering phase of a penetration test. Host enumeration is performed internally and externally. When performed externally, you typically want to limit the IP addresses you are scanning to just the ones that are part of the scope of the test. This reduces the chance of inadvertently scanning an IP address that you are not authorized to test. When performing an internal host enumeration, you typically scan the full subnet or subnets of IP addresses being used by the target. Host enumeration is usually performed using a tool such as Nmap or Masscan; however, vulnerability scanners also perform this task as part of their automated testing. Example 3-23, earlier in this module, shows a sample Nmap ping scan being used for host enumeration on the network 192.168.88.0/24. In earlier versions of Nmap, the Nmap ping scan option was -sP (not -sn ).

User Enumeration

Gathering a valid list of users is the first step in cracking a set of credentials. When you have the username, you can then begin brute-force attempts to get the account password. You perform user enumeration when you have gained access to the internal network. On a Windows network, you can do this by manipulating the Server Message Block (SMB) protocol, which uses TCP port 445. Figure 3-12 illustrates how a typical SMB implementation works.

The information contained in the responses to these messages enables you to reveal information about the server:

SMB_COM_NEGOTIATE: This message allows the client to tell the server what protocols, flags, and options it would like to use. The response from the server is also an SMB_COM_NEGOTIATE message. This response is relayed to the client about which protocols, flags, and options it prefers. This information can be configured on the server itself. A misconfiguration sometimes reveals information that you can use in penetration testing. For instance, the server might be configured to allow messages without signatures. You can determine if the server is using share- or user-level authentication mechanisms and whether the server allows plaintext passwords. The response from the server also provides additional information, such as the time and time zone the server is using. This is necessary information for many penetration testing tasks.
SMB_COM_SESSION_SETUP_ANDX : After the client and server have negotiated the protocols, flags, and options they will use for communication, the authentication process begins. Authentication is the primary function of the SMB_COM_SESSION_SETUP_ANDX message. The information sent in this message includes the client username, password, and domain. If this information is not encrypted, it is easy to sniff it right off the network. Even if it is encrypted, if the mechanism being used is not sufficient, the information can be revealed using tools such as Lanman and NTLM in the case of Microsoft Windows implementations. The following example shows this message being used with the smb-enum-users.nse script:
nmap --script smb-enum-users.nse <host>
Example 3-24 shows the results of the Nmap smb-enum-users script run against the target 192.168.88.251. As you can see, the results indicate that the script was able to enumerate the users who are configured on this Windows target. The highlighted line reveals the user who was enumerated by Nmap (derek).

Group Enumeration

For a penetration tester, group enumeration is helpful in determining the authorization roles that are being used in the target environment. The Nmap NSE script for enumerating SMB groups is smb-enum-groups. This script attempts to pull a list of groups from a remote Windows machine. You can also reveal the list of users who are members of those groups. The syntax of the command is as follows:

nmap --script smb-enum-groups.nse -p445 <host>

Network Share Enumeration

Identifying systems on a network that are sharing files, folders, and printers is helpful in building out an attack surface of an internal network. The Nmap smb-enum-shares NSE script uses Microsoft Remote Procedure Call (MSRPC) for network share enumeration. The syntax of the Nmap smb-enum-shares.nse script is as follows:

nmap --script smb-enum-shares.nse -p 445 <host>
Example 3-26 demonstrates the enumeration of SMB shares.

Service Enumeration

Service enumeration is the process of identifying the services running on a remote system, and it is a primary focus of what Nmap does as a port scanner. Earlier discussion in this module highlights the various scan types and how they can be used to bypass filters. When you are connected to a system that is on a directly connected network segment, you can run some additional scripts to enumerate further. A port scan takes the perspective of a credentialed remote user. The Nmap smb-enum-processes NSE script enumerates services on a Windows system, and it does so by using credentials of a user who has access to read the status of services that are running. This is a handy tool for remotely querying a Windows system to determine the exact list of services running. The syntax of the command is as follows:

nmap --script smb-enum-processes.nse --script-args smbusername=<username>, smbpass=<password> -p445 <host>
  



Example 3-26 - Enumerating SMB Shares

Additional SMB Enumeration Examples

The system used in earlier examples (with the IP address 192.168.88.251) is running Linux and Samba. However, it is not easy to determine that it is a Linux system from the results of previous scans. An easy way to perform additional enumeration and fingerprinting of the applications and operating system running on a host is by using the nmap -sC command. The - sC option runs the most common NSE scripts based on the ports found to be open on the target system.

enum4linux 192.168.88.251

Enumeration Using smbclient

|--[root@websploit]
|--- #smbclient -L \\\192.168.88.251



NIKTO SCAN

- #nikto -h 192.168.88.251


ENUMERATING WITH SCRAPY VIA PACKET CRAFTING-----------------
Exploring Enumeration via Packet Crafting

When it comes to enumeration via packet crafting and generation, Scapy is one of pentesters' favorite tools and frameworks. Scapy is a very comprehensive Python-based framework or ecosystem for packet generation. This section looks at some of the simple ways you can use this tool to perform basic network reconnaissance.

NOTE Scapy must be run with root permissions to be able to modify packets.

Launching the Scapy interactive shell is as easy as typing sudo scapy from a terminal window, as illustrated in Figure 3-13.

Figure 3-13 - Starting scapy from the Command Line
-------------------------------------------------------------------
Example 3-34 shows how easy it is to begin crafting packets. In this example, a simple ICMP packet is crafted with malicious_payload as the payload being sent to the destination host 192.168.88.251.

Example 3-34 - Crafting a Simple ICMP Packet Using Scapy

>>> send(IP(dst="192.168.88.251")/ICMP()/"malicious_payload")
.
Sent 1 packets.


Example 3-35 shows the ICMP packet received by the target system (192.168.88.225/vulnhost-1). The tshark packet capture tool is used to capture the crafted ICMP packet.

Example 3-35 - Collecting a Crafted Packet by Using tshark

omar@vulnhost-1 ~ % sudo tshark host 192.168.78.142
Capturing on 'eth0'
     1 0.000000000 192.168.78.142 ? 192.168.88.251 ICMP 60 Echo (ping) request  id=0x0000, seq=0/0, ttl=63
     2 0.000026929 192.168.88.251 ? 192.168.78.142 ICMP 59 Echo (ping) reply    id=0x0000, seq=0/0, ttl=64 (request in 1)

Scapy supports a large number of protocols. You can use the ls() function to list all available formats and protocols, as demonstrated in Example 3-36.

Example 3-36 - The Scapy ls() Function

>>> ls()
AH          : AH
AKMSuite   : AKM suite
ARP         : ARP
ASN1P_INTEGER : None
ASN1P_OID  : None
ASN1P_PRIVSEQ : None
ASN1_Packet : None
ATT_Error_Response : Error Response
ATT_Exchange_MTU_Request : Exchange MTU Request
ATT_Exchange_MTU_Response : Exchange MTU Response
ATT_Execute_Write_Request : Execute Write Request
ATT_Execute_Write_Response : Execute Write Response
ATT_Find_By_Type_Value_Request : Find By Type Value Request
ATT_Find_By_Type_Value_Response : Find By Type Value Response
ATT_Find_Information_Request : Find Information Request
ATT_Find_Information_Response : Find Information Response
ATT_Handle : ATT Short Handle
ATT_Handle_UUID128 : ATT Handle (UUID 128)
ATT_Handle_Value_Indication : Handle Value Indication
ATT_Handle_Value_Notification : Handle Value Notification
ATT_Handle_Variable : None
ATT_Hdr    : ATT header
ATT_Prepare_Write_Request : Prepare Write Request
<output omitted for brevity>


You can use the ls() function to display all the options and fields of a specific protocol or packet format supported by Scapy, as shown in Example 3-37. This example shows the available fields for the TCP protocol.

Example 3-37 - Listing the TCP Layer 4 Fields in Scapy

>>> ls(TCP)
sport         : ShortEnumField                     = (20)
dport         : ShortEnumField                     = (80)
seq           : IntField                           = (0)
ack           : IntField                           = (0)
dataofs       : BitField  (4 bits)                 = (None)
reserved      : BitField  (3 bits)                 = (0)
flags         : FlagsField  (9 bits)               = (<Flag 2 (S)>)
window        : ShortField                         = (8192)
chksum        : XShortField                        = (None)
urgptr        : ShortField                         = (0)
options       : TCPOptionsField                    = (b'')


Example 3-38 shows the DNS packet fields that can be modified by Scapy.

Example 3-38 - Listing the Available DNS Packet Fields in Scapy

>>> ls(DNS)
length       : ShortField (Cond)                 = (None)
id           : ShortField                        = (0)
qr           : BitField  (1 bit)                 = (0)
opcode       : BitEnumField  (4 bits)            = (0)
aa           : BitField  (1 bit)                 = (0)
tc           : BitField  (1 bit)                 = (0)
rd           : BitField  (1 bit)                 = (1)
ra           : BitField  (1 bit)                 = (0)
z            : BitField  (1 bit)                 = (0)
ad           : BitField  (1 bit)                 = (0)
cd           : BitField  (1 bit)                 = (0)
rcode        : BitEnumField  (4 bits)            = (0)
qdcount      : DNSRRCountField                   = (None)
ancount      : DNSRRCountField                   = (None)
nscount      : DNSRRCountField                   = (None)
arcount      : DNSRRCountField                   = (None)
qd           : DNSQRField                        = (None)
an           : DNSRRField                        = (None)
ns           : DNSRRField                        = (None)
ar           : DNSRRField                        = (None)


You can use the explore() function to navigate the Scapy layers and protocols. After you execute the explore() function, the screen in Figure 3-14 is displayed.

Figure 3-14 - Using the explore() Function in Scapy

You can use the explore() function with any packet format or protocol. Example 3-39 shows the packets contained in scapy.layers.dns using the explore(“dns”) function.

Example 3-39 - Using the explore(“dns”) Function to Display the Packet Types in scapy. layers.dns

>>> explore("dns")
Packets contained in scapy.layers.dns:
Class                      |Name
---------------------------|------------------------------
DNS                        |DNS
DNSQR                      |DNS Question Record
DNSRR                      |DNS Resource Record
DNSRRDLV                   |DNS DLV Resource Record
DNSRRDNSKEY                |DNS DNSKEY Resource Record
DNSRRDS                    |DNS DS Resource Record
DNSRRMX                    |DNS MX Resource Record
DNSRRNSEC                  |DNS NSEC Resource Record
DNSRRNSEC3                 |DNS NSEC3 Resource Record
DNSRRNSEC3PARAM            |DNS NSEC3PARAM Resource Record
DNSRROPT                   |DNS OPT Resource Record
DNSRRRSIG                  |DNS RRSIG Resource Record
DNSRRSOA                   |DNS SOA Resource Record
DNSRRSRV                   |DNS SRV Resource Record
DNSRRTSIG                  |DNS TSIG Resource Record
EDNS0TLV                   |DNS EDNS0 TLV
InheritOriginDNSStrPacket|

You can use Scapy as a scanner in many different ways. Omar Santos has several examples of Python scripts to perform network and system scanning using Scapy at his GitHub repository; see https://github.com/The-Art-of-Hacking/h4cker/blob/master/python_ruby_and_bash. However, you can do a simple TCP SYN scan to any given port, as demonstrated in Example 3-40. In this example, a TCP port 445 SYN packet is sent to the host with the IP address 192.168.88.251. The output indicates that it received one answer, but it doesn’t specify what the actual answer (response) was.

Example 3-40 - Sending a TCP SYN Packet Using Scapy

>>> ans, unans = sr(IP(dst='192.168.88.251')/TCP(dport=445,flags='S'))
Begin emission:
Finished sending 1 packets.
....*
Received 5 packets, got 1 answers, remaining 0 packets
>>>


Example 3-41 shows the packet capture on the target host (192.168.88.251).

Example 3-41 - The Packet Capture of the TCP Packets on the Target Host

omar@vulnhost-1 ~ % sudo tshark host 192.168.78.142
Running as user "root" and group "root". This could be dangerous.
Capturing on 'eth0'
     1 0.000000000 192.168.78.142 ? 192.168.88.251 TCP 60 20 ? 445 [SYN] Seq=0 Win=8192 Len=0
     2 0.000033735 192.168.88.251 ? 192.168.78.142 TCP 58 445 ? 20 [SYN, ACK] Seq=0 Ack=1 Win=64240 Len=0 MSS=1460
      3 0.001065273 192.168.78.142 ? 192.168.88.251 TCP 60 20 ? 445 [RST] Seq=1 Win=0 Len=0



SCRAPING WITH SCRAPY--------------------
Part 2: Use Scapy to Sniff Network Traffic
Scapy can be used to capture and display network traffic, similar to a tcpdump or tshark packet collection.

Step 1: Use the sniff() function.
Use the sniff() function to collect traffic using the default eth0 interface of your VM. Start the capture with the sniff() function without specifying any arguments.
>>> sniff()
Open a second terminal window and ping an internet address, such as www.cisco.com. Remember to specify the count using the -c argument.
┌──(kali㉿kali)-[~]
└─$ ping -c 5 www.cisco.com
Return to the terminal window that is running the Scapy tool. Press CTRL-C to stop the capture. You should receive output similar to what is shown here:
^C<Sniffed: TCP:75 UDP:42 ICMP:32 Other:2>
View the captured traffic using the summary() function. The a=_ assigns the variable a to hold the output of the sniff() function. The underscore ( _ ) in Python is used to temporarily hold the output of the last function executed.
>>> a=_
>>> a.summary()
The output of this command can be extensive, depending on the applications running on the network.

Step 2:  Capture and save traffic on a specific interface.
In this step, you will capture traffic to and from a device connected to a virtual network in your Kali Linux VM.

Open a new terminal window. Use the ifconfig command to determine the name of the interface that is assigned the IP address 10.6.6.1. This is the default gateway address for one of the virtual networks running inside Kali. Note the name of interface.
Return to the terminal window that is running the Scapy tool. Use the syntax sniff(iface="interface name") to begin the capture on the br-internal virtual interface.
>>> sniff(iface="br-internal")
Open Firefox and navigate to the URL http://10.6.6.23/. When the Gravemind home page opens, return to the terminal window that is running the Scapy tool. Press CTRL-C. You should receive output similar to:
^C<Sniffed: TCP:112 UDP:0 ICMP:0 Other:2>
View the captured traffic as you did in Step 1d.
>>> a=_
>>> a.summary()
Step 3: Examine the collected packets.
In this step, you will filter the collected traffic to include only ICMP traffic, limit the number of packets being collected, and view the individual packet details.

Use interface ID associated with 10.6.6.1 (br-internal) to capture ten ICMP packets sent and received on the internal virtual network. The syntax is sniff(iface="interface name", filter = “protocol", count = integer).
>>> sniff(iface="br-internal",filter = “icmp",count = 10)
Open a second terminal window and ping the host at 10.6.6.23.
┌──(kali㉿Kali)-[~]
└─$ ping –c 10 10.6.6.23
Return to the terminal window running the Scapy tool. The capture automatically stopped when 10 packets were sent or received. View the captured traffic with line numbers using the nsummary() function.
>>>  a=_ 
>>>  a.nsummary()
The summary should only contain 10 lines because the capture count is equal to 10.

Part 3: Create and Send an ICMP Packet.
ICMP is a protocol designed to send control messages between network devices for various purposes. There are many types of ICMP packets, with echo-request and echo-reply the most familiar to IT technicians. To see a list of the message types that can be sent and received using ICMP, navigate to https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml.

Step 1: Use interactive mode to create and send a custom ICMP packet.
In a Scapy terminal window, enter the command to sniff traffic from the interface connected to the 10.6.6.0/24 network.
>>> sniff(iface="br-internal")
Open another terminal window, enter sudo su to perform packet crafting as root. Start a second instance of Scapy. Enter the send() function to send a packet to 10.6.6.23 with a modified ICMP payload.
┌──(kali㉿kali)-[~]
└─$ sudo su
[sudo] password for kali:
┌──(root㉿kali)-[/home/kali]
└─# scapy
 
>>> send(IP(dst="10.6.6.23")/ICMP()/"This is a test")
   
Response
Sent 1 packet
Return to the first terminal window and press CTRL-C. You should receive a response similar to this:
^C<Sniffed: TCP:0 UDP:0 ICMP:2 Other:0>
Enter the summary command to display the summary with packet numbers.
>>> a=_
>>> a.nsummary()

Step 2: View and compare the ICMP packet contents.
Use the packet numbers to view the individual ICMP Echo-request and Echo-reply packets. Compare those packets to the ones that you examined in Part 2, Step 3d.

>>> a[packet number]
What is different between the original ICMP packet conversation and the custom ICMP packet conversation?
>>>
>>> Part 4: Create and Send a TCP SYN Packet.
In this part, you will use Scapy to determine if port 445, a Microsoft Windows drive share port, is open on the target system at 10.6.6.23.

Step 1: Start the packet capture on the internal interface.
In the original Scapy terminal window, begin a packet capture on the internal interface attached to the 10.6.6.0/24 network. Use the interface name that you obtained previously.
Navigate to the second terminal window. Create and send a TCP SYN packet using the command shown.
>>> send(IP(dst="10.6.6.23")/TCP(dport=445, flags="S"))
1 packet sent
This command sent an IP packet to the host with IP address 10.6.6.23. The packet is addressed to TCP port 445 and has the S (SYN) flag set.

Close the terminal window.
Step 2: Review the captured packets.
In the original Scapy terminal window, stop the packet capture by pressing CTRL-C. The output should be similar to that shown.
^C<Sniffed: TCP:3 UDP:0 ICMP:0 Other:0>
View the captured TCP packets using the nsummary() function. Display the detail of the TCP packet that was returned from the target computer at 10.6.6.23.
>>> a[packet number]

In some cases, it is best to run an authenticated scan against a target to get a full picture of the attack surface. An authenticated scan requires you to provide the scanner with a set of credentials that have root-level access to the system. The scanner actually logs in to the target via SSH or some other mechanism. It then runs commands like netstat to gather information from inside the host. Many of the commands that the scanner runs require root-level access to be able to gather the correct information from the system.

Example 3-42 shows the netstat command run by a non-privileged user (omar); Example 3-43 shows the netstat command run by a root user. You can see that the output is different for the different user-level permissions. Specifically, notice that when running as the user omar, the PID/program name is not available, and when running as the user root, that information is displayed.

Example 3-42 - Netstat Example Without Root-Level Access











# WEB APPLICATION PENTESTING CHECKLIST

**OWASP Based Checklist  🌟🌟**

**500+ Test Cases 🚀🚀**

Notion link: https://hariprasaanth.notion.site/WEB-APPLICATION-PENTESTING-CHECKLIST-0f02d8074b9d4af7b12b8da2d46ac998
</br></br>





- **INFORMATION GATHERING**
    
    **Open Source Reconnaissance**
    
    - [ ]  Perform Google Dorks search
    - [ ]  Perform OSINT
    
    **Fingerprinting Web Server**
    
    - [ ]  Find the type of Web Server
    - [ ]  Find the version details of the Web Server
    
    **Looking For Metafiles**
    
    - [ ]  View the Robots.txt file
    - [ ]  View the Sitemap.xml file
    - [ ]  View the Humans.txt file
    - [ ]  View the Security.txt file
    
    **Enumerating Web Server’s Applications**
    
    - [ ]  Enumerating with Nmap
    - [ ]  Enumerating with Netcat
    - [ ]  Perform a DNS lookup
    - [ ]  Perform a Reverse DNS lookup
    
    **Review The Web Contents**
    
    - [ ]  Inspect the page source for sensitive info
    - [ ]  Try to find Sensitive Javascript codes
    - [ ]  Try to find any keys
    - [ ]  Make sure the autocomplete is disabled
    
    **Identifying Application’s Entry Points**
    
    - [ ]  Identify what the methods used are?
    - [ ]  Identify where the methods used are?
    - [ ]  Identify the Injection point
    
    **Mapping Execution Paths**
    
    - [ ]  Use Burp Suite
    - [ ]  Use Dirsearch
    - [ ]  Use Gobuster
    
    **Fingerprint Web Application Framework**
    
    - [ ]  Use the Wappalyzer browser extension
    - [ ]  Use Whatweb
    - [ ]  View URL extensions
    - [ ]  View HTML source code
    - [ ]  View the cookie parameter
    - [ ]  View the HTTP headers
    
    **Map Application Architecture**
    
    - [ ]  Map the overall site structure
    
- **CONFIGURATION & DEPLOYMENT MANAGEMENT TESTING**
    
    **Test Network Configuration**
    
    - [ ]  Check the network configuration
    - [ ]  Check for default settings
    - [ ]  Check for default credentials
    
    **Test Application Configuration**
    
    - [ ]  Ensure only required modules are used
    - [ ]  Ensure unwanted modules are disabled
    - [ ]  Ensure the server can handle DOS
    - [ ]  Check how the application is handling 4xx & 5xx errors
    - [ ]  Check for the privilege required to run
    - [ ]  Check logs for sensitive info
    
    **Test File Extension Handling**
    
    - [ ]  Ensure the server won’t return sensitive extensions
    - [ ]  Ensure the server won’t accept malicious extensions
    - [ ]  Test for file upload vulnerabilities
    
    **Review Backup & Unreferenced Files**
    
    - [ ]  Ensure unreferenced files don’t contain any sensitive info
    - [ ]  Ensure the namings of old and new backup files
    - [ ]  Check the functionality of unreferenced pages
    
    **Enumerate Infrastructure & Admin Interfaces**
    
    - [ ]  Try to find the Infrastructure Interface
    - [ ]  Try to find the Admin Interface
    - [ ]  Identify the hidden admin functionalities
    
    **Testing HTTP Methods**
    
    - [ ]  Discover the supported methods
    - [ ]  Ensure the PUT method is disabled
    - [ ]  Ensure the OPTIONS method is disabled
    - [ ]  Test access control bypass
    - [ ]  Test for XST attacks
    - [ ]  Test for HTTP method overriding
    
    **Test HSTS**
    
    - [ ]  Ensure HSTS is enabled
    
    **Test RIA Cross Domain Policy**
    
    - [ ]  Check for Adobe’s Cross Domain Policy
    - [ ]  Ensure it has the least privilege
    
    **Test File Permission**
    
    - [ ]  Ensure the permissions for sensitive files
    - [ ]  Test for directory enumeration
    
    **Test For Subdomain Takeover**
    
    - [ ]  Test DNS, A, and CNAME records for subdomain takeover
    - [ ]  Test NS records for subdomain takeover
    - [ ]  Test 404 response for subdomain takeover
    
    **Test Cloud Storage**
    
    - [ ]  Check the sensitive paths of AWS
    - [ ]  Check the sensitive paths of Google Cloud
    - [ ]  Check the sensitive paths of Azure
    
- **IDENTITY MANAGEMENT TESTING**
    
    **Test Role Definitions**
    
    - [ ]  Test for forced browsing
    - [ ]  Test for IDOR (Insecure Direct Object Reference)
    - [ ]  Test for parameter tampering
    - [ ]  Ensure low privilege users can’t able to access high privilege resources
    
    **Test User Registration Process**
    
    - [ ]  Ensure the same user or identity can’t register again and again
    - [ ]  Ensure the registrations are verified
    - [ ]  Ensure disposable email addresses are rejected
    - [ ]  Check what proof is required for successful registration
    
    **Test Account Provisioning Process**
    
    - [ ]  Check the verification for the provisioning process
    - [ ]  Check the verification for the de-provisioning process
    - [ ]  Check the provisioning rights for an admin user to other users
    - [ ]  Check whether a user is able to de-provision themself or not?
    - [ ]  Check for the resources of a de-provisioned user
    
    **Testing For Account Enumeration**
    
    - [ ]  Check the response when a valid username and password entered
    - [ ]  Check the response when a valid username and an invalid password entered
    - [ ]  Check the response when an invalid username and password entered
    - [ ]  Ensure the rate-limiting functionality is enabled in username and password fields
    
    **Test For Weak Username Policy**
    
    - [ ]  Check the response for both valid and invalid usernames
    - [ ]  Check for username enumeration
    
- **AUTHENTICATION TESTING**
    
    **Test For Un-Encrypted Channel**
    
    - [ ]  Check for the HTTP login page
    - [ ]  Check for the HTTP register or sign-in page
    - [ ]  Check for HTTP forgot password page
    - [ ]  Check for HTTP change password
    - [ ]  Check for resources on HTTP after logout
    - [ ]  Test for forced browsing to HTTP pages
    
    **Test For Default Credentials**
    
    - [ ]  Test with default credentials
    - [ ]  Test organization name as credentials
    - [ ]  Test for response manipulation
    - [ ]  Test for the default username and a blank password
    - [ ]  Review the page source for credentials
    
    **Test For Weak Lockout Mechanism**
    
    - [ ]  Ensure the account has been locked after 3-5 incorrect attempts
    - [ ]  Ensure the system accepts only the valid CAPTCHA
    - [ ]  Ensure the system rejects the invalid CAPTCHA
    - [ ]  Ensure CAPTCHA code regenerated after reloaded
    - [ ]  Ensure CAPTCHA reloads after entering the wrong code
    - [ ]  Ensure the user has a recovery option for a lockout account
    
    **Test For Bypassing Authentication Schema**
    
    - [ ]  Test forced browsing directly to the internal dashboard without login
    - [ ]  Test for session ID prediction
    - [ ]  Test for authentication parameter tampering
    - [ ]  Test for SQL injection on the login page
    - [ ]  Test to gain access with the help of session ID
    - [ ]  Test multiple logins allowed or not?
    
    **Test For Vulnerable Remember Password**
    
    - [ ]  Ensure that the stored password is encrypted
    - [ ]  Ensure that the stored password is on the server-side
    
    **Test For Browser Cache Weakness**
    
    - [ ]  Ensure proper cache-control is set on sensitive pages
    - [ ]  Ensure no sensitive data is stored in the browser cache storage
    
    **Test For Weak Password Policy**
    
    - [ ]  Ensure the password policy is set to strong
    - [ ]  Check for password reusability
    - [ ]  Check the user is prevented to use his username as a password
    - [ ]  Check for the usage of common weak passwords
    - [ ]  Check the minimum password length to be set
    - [ ]  Check the maximum password length to be set
    
    **Testing For Weak Security Questions**
    
    - [ ]  Check for the complexity of the questions
    - [ ]  Check for brute-forcing
    
    **Test For Weak Password Reset Function**
    
    - [ ]  Check what information is required to reset the password
    - [ ]  Check for password reset function with HTTP
    - [ ]  Test the randomness of the password reset tokens
    - [ ]  Test the uniqueness of the password reset tokens
    - [ ]  Test for rate limiting on password reset tokens
    - [ ]  Ensure the token must expire after being used
    - [ ]  Ensure the token must expire after not being used for a long time
    
    **Test For Weak Password Change Function**
    
    - [ ]  Check if the old password asked to make a change
    - [ ]  Check for the uniqueness of the forgotten password
    - [ ]  Check for blank password change
    - [ ]  Check for password change function with HTTP
    - [ ]  Ensure the old password is not displayed after changed
    - [ ]  Ensure the other sessions got destroyed after the password change
    
    **Test For Weak Authentication In Alternative Channel**
    
    - [ ]  Test authentication on the desktop browsers
    - [ ]  Test authentication on the mobile browsers
    - [ ]  Test authentication in a different country
    - [ ]  Test authentication in a different language
    - [ ]  Test authentication on desktop applications
    - [ ]  Test authentication on mobile applications
    
- **AUTHORIZATION TESTING**
    
    **Testing Directory Traversal File Include**
    
    - [ ]  Identify the injection point on the URL
    - [ ]  Test for Local File Inclusion
    - [ ]  Test for Remote File Inclusion
    - [ ]  Test Traversal on the URL parameter
    - [ ]  Test Traversal on the cookie parameter
    
    **Testing Traversal With Encoding**
    
    - [ ]  Test Traversal with Base64 encoding
    - [ ]  Test Traversal with URL encoding
    - [ ]  Test Traversal with ASCII encoding
    - [ ]  Test Traversal with HTML encoding
    - [ ]  Test Traversal with Hex encoding
    - [ ]  Test Traversal with Binary encoding
    - [ ]  Test Traversal with Octal encoding
    - [ ]  Test Traversal with Gzip encoding
    
    **Testing Travesal With Different OS Schemes**
    
    - [ ]  Test Traversal with Unix schemes
    - [ ]  Test Traversal with Windows schemes
    - [ ]  Test Traversal with Mac schemes
    
    **Test Other Encoding Techniques**
    
    - [ ]  Test Traversal with Double encoding
    - [ ]  Test Traversal with all characters encode
    - [ ]  Test Traversal with only special characters encode
    
    **Test Authorization Schema Bypass**
    
    - [ ]  Test for Horizontal authorization schema bypass
    - [ ]  Test for Vertical authorization schema bypass
    - [ ]  Test override the target with custom headers
    
    **Test For Privilege Escalation**
    
    - [ ]  Identify the injection point
    - [ ]  Test for bypassing the security measures
    - [ ]  Test for forced browsing
    - [ ]  Test for IDOR
    - [ ]  Test for parameter tampering to high privileged user
    
    **Test For Insecure Direct Object Reference**
    
    - [ ]  Test to change the ID parameter
    - [ ]  Test to add parameters at the endpoints
    - [ ]  Test for HTTP parameter pollution
    - [ ]  Test by adding an extension at the end
    - [ ]  Test with outdated API versions
    - [ ]  Test by wrapping the ID with an array
    - [ ]  Test by wrapping the ID with a JSON object
    - [ ]  Test for JSON parameter pollution
    - [ ]  Test by changing the case
    - [ ]  Test for path traversal
    - [ ]  Test by changing words
    - [ ]  Test by changing methods
    
- **SESSION MANAGEMENT TESTING**
    
    **Test For Session Management Schema**
    
    - [ ]  Ensure all Set-Cookie directives are secure
    - [ ]  Ensure no cookie operation takes place over an unencrypted channel
    - [ ]  Ensure the cookie can’t be forced over an unencrypted channel
    - [ ]  Ensure the HTTPOnly flag is enabled
    - [ ]  Check if any cookies are persistent
    - [ ]  Check for session cookies and cookie expiration date/time
    - [ ]  Check for session fixation
    - [ ]  Check for concurrent login
    - [ ]  Check for session after logout
    - [ ]  Check for session after closing the browser
    - [ ]  Try decoding cookies (Base64, Hex, URL, etc)
    
    **Test For Cookie Attributes**
    
    - [ ]  Ensure the cookie must be set with the secure attribute
    - [ ]  Ensure the cookie must be set with the path attribute
    - [ ]  Ensure the cookie must have the HTTPOnly flag
    
    **Test For Session Fixation**
    
    - [ ]  Ensure new cookies have been issued upon a successful authentication
    - [ ]  Test manipulating the cookies
    
    **Test For Exposed Session Variables**
    
    - [ ]  Test for encryption
    - [ ]  Test for GET and POST vulnerabilities
    - [ ]  Test if GET request incorporating the session ID used
    - [ ]  Test by interchanging POST with GET method
    
    **Test For Back Refresh Attack**
    
    - [ ]  Test after password change
    - [ ]  Test after logout
    
    **Test For Cross Site Request Forgery**
    
    - [ ]  Check if the token is validated on the server-side or not
    - [ ]  Check if the token is validated for full or partial length
    - [ ]  Check by comparing the CSRF tokens for multiple dummy accounts
    - [ ]  Check CSRF by interchanging POST with GET method
    - [ ]  Check CSRF by removing the CSRF token parameter
    - [ ]  Check CSRF by removing the CSRF token and using a blank parameter
    - [ ]  Check CSRF by using unused tokens
    - [ ]  Check CSRF by replacing the CSRF token with its own values
    - [ ]  Check CSRF by changing the content type to form-multipart
    - [ ]  Check CSRF by changing or deleting some characters of the CSRF token
    - [ ]  Check CSRF by changing the referrer to Referrer
    - [ ]  Check CSRF by changing the host values
    - [ ]  Check CSRF alongside clickjacking
    
    **Test For Logout Functionality**
    
    - [ ]  Check the log out function on different pages
    - [ ]  Check for the visibility of the logout button
    - [ ]  Ensure after logout the session was ended
    - [ ]  Ensure after logout we can’t able to access the dashboard by pressing the back button
    - [ ]  Ensure proper session timeout has been set
    
    **Test For Session Timeout**
    
    - [ ]  Ensure there is a session timeout exists
    - [ ]  Ensure after the timeout, all of the tokens are destroyed
    
    **Test For Session Puzzling**
    
    - [ ]  Identify all the session variables
    - [ ]  Try to break the logical flow of the session generation
    
    **Test For Session Hijacking**
    
    - [ ]  Test session hijacking on target that doesn’t has HSTS enabled
    - [ ]  Test by login with the help of captured cookies
    
- **INPUT VALIDATION TESTING**
    
    **Test For Reflected Cross Site Scripting**
    
    - [ ]  Ensure these characters are filtered <>’’&””
    - [ ]  Test with a character escape sequence
    - [ ]  Test by replacing < and > with HTML entities &lt; and &gt;
    - [ ]  Test payload with both lower and upper case
    - [ ]  Test to break firewall regex by new line /r/n
    - [ ]  Test with double encoding
    - [ ]  Test with recursive filters
    - [ ]  Test injecting anchor tags without whitespace
    - [ ]  Test by replacing whitespace with bullets
    - [ ]  Test by changing HTTP methods
    
    **Test For Stored Cross Site Scripting**
    
    - [ ]  Identify stored input parameters that will reflect on the client-side
    - [ ]  Look for input parameters on the profile page
    - [ ]  Look for input parameters on the shopping cart page
    - [ ]  Look for input parameters on the file upload page
    - [ ]  Look for input parameters on the settings page
    - [ ]  Look for input parameters on the forum, comment page
    - [ ]  Test uploading a file with XSS payload as its file name
    - [ ]  Test with HTML tags
    
    **Test For HTTP Parameter Pollution**
    
    - [ ]  Identify the backend server and parsing method used
    - [ ]  Try to access the injection point
    - [ ]  Try to bypass the input filters using HTTP Parameter Pollution
    
    **Test For SQL Injection**
    
    - [ ]  Test SQL Injection on authentication forms
    - [ ]  Test SQL Injection on the search bar
    - [ ]  Test SQL Injection on editable characteristics
    - [ ]  Try to find SQL keywords or entry point detections
    - [ ]  Try to inject SQL queries
    - [ ]  Use tools like SQLmap or Hackbar
    - [ ]  Use Google dorks to find the SQL keywords
    - [ ]  Try GET based SQL Injection
    - [ ]  Try POST based SQL Injection
    - [ ]  Try COOKIE based SQL Injection
    - [ ]  Try HEADER based SQL Injection
    - [ ]  Try SQL Injection with null bytes before the SQL query
    - [ ]  Try SQL Injection with URL encoding
    - [ ]  Try SQL Injection with both lower and upper cases
    - [ ]  Try SQL Injection with SQL Tamper scripts
    - [ ]  Try SQL Injection with SQL Time delay payloads
    - [ ]  Try SQL Injection with SQL Conditional delays
    - [ ]  Try SQL Injection with Boolean based SQL
    - [ ]  Try SQL Injection with Time based SQL
    
    **Test For LDAP Injection**
    
    - [ ]  Use LDAP search filters
    - [ ]  Try LDAP Injection for access control bypass
    
    **Testing For XML Injection**
    
    - [ ]  Check if the application is using XML for processing
    - [ ]  Identify the XML Injection point by XML metacharacter
    - [ ]  Construct XSS payload on top of XML
    
    **Test For Server Side Includes**
    
    - [ ]  Use Google dorks to find the SSI
    - [ ]  Construct RCE on top of SSI
    - [ ]  Construct other injections on top of SSI
    - [ ]  Test Injecting SSI on login pages, header fields, referrer, etc
    
    **Test For XPATH Injection**
    
    - [ ]  Identify XPATH Injection point
    - [ ]  Test for XPATH Injection
    
    **Test For IMAP SMTP Injection**
    
    - [ ]  Identify IMAP SMTP Injection point
    - [ ]  Understand the data flow
    - [ ]  Understand the deployment structure of the system
    - [ ]  Assess the injection impact
    
    **Test For Local File Inclusion**
    
    - [ ]  Look for LFI keywords
    - [ ]  Try to change the local path
    - [ ]  Use the LFI payload list
    - [ ]  Test LFI by adding a null byte at the end
    
    **Test For Remote File Inclusion**
    
    - [ ]  Look for RFI keywords
    - [ ]  Try to change the remote path
    - [ ]  Use the RFI payload list
    
    **Test For Command Injection**
    
    - [ ]  Identify the Injection points
    - [ ]  Look for Command Injection keywords
    - [ ]  Test Command Injection using different delimiters
    - [ ]  Test Command Injection with payload list
    - [ ]  Test Command Injection with different OS commands
    
    **Test For Format String Injection**
    
    - [ ]  Identify the Injection points
    - [ ]  Use different format parameters as payloads
    - [ ]  Assess the injection impact
    
    **Test For Host Header Injection**
    
    - [ ]  Test for HHI by changing the real Host parameter
    - [ ]  Test for HHI by adding X-Forwarded Host parameter
    - [ ]  Test for HHI by swapping the real Host and X-Forwarded Host parameter
    - [ ]  Test for HHI by adding two Host parameters
    - [ ]  Test for HHI by adding the target values in front of the original values
    - [ ]  Test for HHI by adding the target with a slash after the original values
    - [ ]  Test for HHI with other injections on the Host parameter
    - [ ]  Test for HHI by password reset poisoning
    
    **Test For Server Side Request Forgery**
    
    - [ ]  Look for SSRF keywords
    - [ ]  Search for SSRF keywords only under the request header and body
    - [ ]  Identify the Injection points
    - [ ]  Test if the Injection points are exploitable
    - [ ]  Assess the injection impact
    
    **Test For Server Side Template Injection**
    
    - [ ]  Identify the Template injection vulnerability points
    - [ ]  Identify the Templating engine
    - [ ]  Use the tplmap to exploit
    
- **ERROR HANDLING TESTING**
    
    **Test For Improper Error Handling**
    
    - [ ]  Identify the error output
    - [ ]  Analyze the different outputs returned
    - [ ]  Look for common error handling flaws
    - [ ]  Test error handling by modifying the URL parameter
    - [ ]  Test error handling by uploading unrecognized file formats
    - [ ]  Test error handling by entering unrecognized inputs
    - [ ]  Test error handling by making all possible errors
    
- **WEAK CRYPTOGRAPHY TESTING**
    
    **Test For Weak Transport Layer Security**
    
    - [ ]  Test for DROWN weakness on SSLv2 protocol
    - [ ]  Test for POODLE weakness on SSLv3 protocol
    - [ ]  Test for BEAST weakness on TLSv1.0 protocol
    - [ ]  Test for FREAK weakness on export cipher suites
    - [ ]  Test for Null ciphers
    - [ ]  Test for NOMORE weakness on RC4
    - [ ]  Test for LUCKY 13 weakness on CBC mode ciphers
    - [ ]  Test for CRIME weakness on TLS compression
    - [ ]  Test for LOGJAM on DHE keys
    - [ ]  Ensure the digital certificates should have at least 2048 bits of key length
    - [ ]  Ensure the digital certificates should have at least SHA-256 signature algorithm
    - [ ]  Ensure the digital certificates should not use MDF and SHA-1
    - [ ]  Ensure the validity of the digital certificate
    - [ ]  Ensure the minimum key length requirements
    - [ ]  Look for weak cipher suites
    
- **BUSINESS LOGIC TESTING**
    
    **Test For Business Logic**
    
    - [ ]  Identify the logic of how the application works
    - [ ]  Identify the functionality of all the buttons
    - [ ]  Test by changing the numerical values into high or negative values
    - [ ]  Test by changing the quantity
    - [ ]  Test by modifying the payments
    - [ ]  Test for parameter tampering
    
    **Test For Malicious File Upload**
    
    - [ ]  Test malicious file upload by uploading malicious files
    - [ ]  Test malicious file upload by putting your IP address on the file name
    - [ ]  Test malicious file upload by right to left override
    - [ ]  Test malicious file upload by encoded file name
    - [ ]  Test malicious file upload by XSS payload on the file name
    - [ ]  Test malicious file upload by RCE payload on the file name
    - [ ]  Test malicious file upload by LFI payload on the file name
    - [ ]  Test malicious file upload by RFI payload on the file name
    - [ ]  Test malicious file upload by SQL payload on the file name
    - [ ]  Test malicious file upload by other injections on the file name
    - [ ]  Test malicious file upload by Inserting the payload inside of an image by the bmp.pl tool
    - [ ]  Test malicious file upload by uploading large files (leads to DOS)
    
- **CLIENT SIDE TESTING**
    
    **Test For DOM Based Cross Site Scripting**
    
    - [ ]  Try to identify DOM sinks
    - [ ]  Build payloads to that DOM sink type
    
    **Test For URL Redirect**
    
    - [ ]  Look for URL redirect parameters
    - [ ]  Test for URL redirection on domain parameters
    - [ ]  Test for URL redirection by using a payload list
    - [ ]  Test for URL redirection by using a whitelisted word at the end
    - [ ]  Test for URL redirection by creating a new subdomain with the same as the target
    - [ ]  Test for URL redirection by XSS
    - [ ]  Test for URL redirection by profile URL flaw
    
    **Test For Cross Origin Resource Sharing**
    
    - [ ]  Look for “Access-Control-Allow-Origin” on the response
    - [ ]  Use the CORS HTML exploit code for further exploitation
    
    **Test For Clickjacking**
    
    - [ ]  Ensure “X-Frame-Options” headers are enabled
    - [ ]  Exploit with iframe HTML code for POC
    
- **OTHER COMMON ISSUES**
    
    **Test For No-Rate Limiting**
    
    - [ ]  Ensure rate limiting is enabled
    - [ ]  Try to bypass rate limiting by changing the case of the endpoints
    - [ ]  Try to bypass rate limiting by adding / at the end of the URL
    - [ ]  Try to bypass rate limiting by adding HTTP headers
    - [ ]  Try to bypass rate limiting by adding HTTP headers twice
    - [ ]  Try to bypass rate limiting by adding Origin headers
    - [ ]  Try to bypass rate limiting by IP rotation
    - [ ]  Try to bypass rate limiting by using null bytes at the end
    - [ ]  Try to bypass rate limiting by using race conditions
    
    **Test For EXIF Geodata**
    
    - [ ]  Ensure the website is striping the geodata
    - [ ]  Test with EXIF checker
    
    **Test For Broken Link Hijack**
    
    - [ ]  Ensure there is no broken links are there
    - [ ]  Test broken links by using the blc tool
    
    **Test For SPF**
    
    - [ ]  Ensure the website is having SPF record
    - [ ]  Test SPF by nslookup command
    
    **Test For Weak 2FA**
    
    - [ ]  Try to bypass 2FA by using poor session management
    - [ ]  Try to bypass 2FA via the OAuth mechanism
    - [ ]  Try to bypass 2FA via brute-forcing
    - [ ]  Try to bypass 2FA via response manipulation
    - [ ]  Try to bypass 2FA by using activation links to login
    - [ ]  Try to bypass 2FA by using status code manipulation
    - [ ]  Try to bypass 2FA by changing the email or password
    - [ ]  Try to bypass 2FA by using a null or empty entry
    - [ ]  Try to bypass 2FA by changing the boolean into false
    - [ ]  Try to bypass 2FA by removing the 2FA parameter on the request
    
    **Test For Weak OTP Implementation**
    
    - [ ]  Try to bypass OTP by entering the old OTP
    - [ ]  Try to bypass OTP by brute-forcing
    - [ ]  Try to bypass OTP by using a null or empty entry
    - [ ]  Try to bypass OTP by response manipulation
    - [ ]  Try to bypass OTP by status code manipulation
    

### Shaped by: Hariprasaanth R

**Reach Me: [LinkedIn](https://www.linkedin.com/in/hariprasaanth) [Portfolio](https://hariprasaanth.blogspot.com/) [Github](https://github.com/Hari-prasaanth)**
